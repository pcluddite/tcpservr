<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".Generated.cs" #>
// ======
//
// Copyright (c) Timothy Baxendale. All Rights Reserved.
//
// ======
using System;
using System.Diagnostics.Contracts;
using Tbasic.Types;

namespace Tbasic.Libraries
{
    // Autogenerated. Do not modify this file.
    public partial class Library
    {
<# BuildAll(10); #>
    }
}
<#+

private void BuildAll(int numArgs)
{
    for(int i = 0; i <= numArgs; ++i) {
        BuildAddFunc(i);
        WriteLine("");
        BuildAddAction(i);
        WriteLine("");
    }

    
}

private void BuildAddFunc(int numArgs)
{
        string generic;
        if (numArgs > 0) {
            generic = ExpandTypeParams(numArgs) + ", ";
        }
        else {
            generic = "";
        }
#>
        /// <summary>
        /// Adds a native function that returns a result
        /// </summary>
<#+ BuildDocs(numArgs); #>
        /// <typeparam name="TResult">the type that this function returns</typeparam>
        public void Add<<#= generic #>TResult>(string key, Func<<#= generic #>TResult> value, bool evaluate = true, int requiredArgs = -1)
        {
            if (key == null)
                throw new ArgumentNullException(nameof(key));
            if (value == null)
                throw new ArgumentNullException(nameof(value));
            Contract.EndContractBlock();

            if (requiredArgs < 0)
                requiredArgs = <#= numArgs #>;
            Add(key, new CallData(value, requiredArgs, evaluate));
        }
<#+
}

private void BuildAddAction(int numArgs)
{
        string generic;
        if (numArgs > 0) {
            generic = $"<{ExpandTypeParams(numArgs)}>";
        }
        else {
            generic = "";
        }
#>
        /// <summary>
        /// Adds a native function that does not return a result
        /// </summary>
<#+ BuildDocs(numArgs); #>
        public void Add<#= generic #>(string key, Action<#= generic #> value, bool evaluate = true, int requiredArgs = -1)
        {
            if (key == null)
                throw new ArgumentNullException(nameof(key));
            if (value == null)
                throw new ArgumentNullException(nameof(value));
            Contract.EndContractBlock();

            if (requiredArgs < 0)
                requiredArgs = <#= numArgs #>;
            Add(key, new CallData(value, requiredArgs, evaluate));
        }
<#+
}

private void BuildDocs(int numArgs)
{
#>
        /// <param name="key">the name of the function</param>
        /// <param name="value">the delegate to the function</param>
        /// <param name="evaluate">True if function should have its arguments evaluated before they are passed, false otherwise</param>
        /// <param name="requiredArgs">The number of arguments that this function is required to have. Values less than zero mean all arguments are required.</param>
<#+     for (int i = 0; i < numArgs; ++i) { #>
        /// <typeparam name="T<#= i + 1 #>">the type for argument <#= i + 1 #></typeparam>
<#+		}
#>
<#+
}

private string ExpandTypeParams(int argCount) {
    string[] args = new string[argCount];
    for(int i = 0; i < argCount; ++i) {
        args[i] = $"T{i + 1}";
    }
    return string.Join(", ", args);
} #>