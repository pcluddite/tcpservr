// ======
//
// Copyright (c) Timothy Baxendale. All Rights Reserved.
//
// ======
using System;
using Tbasic.Runtime;

namespace Tbasic.Types
{
    // Autogenerated. Do not modify this file.
    internal static class TypeConvert
    {
        /// <summary>
        /// Tries to convert an object to a given type. First this tries to do a straight up cast. If that doesn't work and strict is turned off, it will try to be converted with IConvertible. If the object is a string and parseStrings is turned on, it will try to parse that string.
        /// </summary>
        /// <typeparam name="T">the type to convert to</typeparam>
        /// <param name="obj">the object to convert</param>
        /// <param name="result">the result of the conversion</param>
        /// <param name="opts">the options for converting</param>
        /// <returns></returns>
        internal static bool TryConvert<T>(object obj,  out T result, ExecuterOption opts)
        {
            if (obj is T) {
                result = (T)obj;
                return true;
            }
            else {
                if (!opts.HasFlag(ExecuterOption.Strict))
                    return TryConvertNonStrict(obj, out result, opts);
                result = default(T);
                return false;
            }
        }

        /// <summary>
        /// Tries to convert an object to a given type. First this tries to do a straight up cast. If that doesn't work and strict is turned off, it will try to be converted with IConvertible. If the object is a string and parseStrings is turned on, it will try to parse that string.
        /// </summary>
        /// <param name="type">the type to convert to</param>
        /// <param name="obj">the object to convert</param>
        /// <param name="result">the result of the conversion</param>
        /// <param name="opts">the options for converting</param>
        /// <returns></returns>
        internal static bool TryConvert(object obj,  Type type, out object result, ExecuterOption opts)
        {
            if (type.IsAssignableFrom(obj.GetType())) {
                result = obj;
                return true;
            }
            else {
                if (!opts.HasFlag(ExecuterOption.Strict))
                    return TryConvertNonStrict(obj, type, out result, opts);
                result = default(object);
                return false;
            }
        }

        private static bool TryConvertNonStrict<T>(object obj, out T result, ExecuterOption opts)
        {
            result = default(T);
            if (!opts.HasFlag(ExecuterOption.EnforceStrings)) {
                string str = obj as string; // maybe we can convert it from a string?
                if (str != null) {
                    obj = ConvertFromString(str);
                    if (obj == null)
                        return false;
                    return TryConvert(obj, out result, ExecuterOption.None); // it's a good old fashion type now. try again.
                }
            }
            if (obj is IConvertible) {
                try {
                    result = (T)Convert.ChangeType(obj, typeof(T));
                    return true;
                }
                catch(InvalidCastException) {
                    if (typeof(T).IsEnum) {
                        Number? n = obj as Number?;
                        if (n != null) {
                            return TryConvert((int)n, out result, ExecuterOption.Strict); // if we don't turn on strict, we'll have infinite recursion 8/22/16
                        }
                    }
                    return false;
                }
                catch (Exception ex) when (ex is FormatException || ex is OverflowException) {
                    return false;
                }
            }
            else {
                return false;
            }
        }

        private static bool TryConvertNonStrict(object obj, Type type, out object result, ExecuterOption opts)
        {
            result = default(object);
            if (!opts.HasFlag(ExecuterOption.EnforceStrings)) {
                string str = obj as string; // maybe we can convert it from a string?
                if (str != null) {
                    obj = ConvertFromString(str);
                    if (obj == null)
                        return false;
                    return TryConvert(obj, out result, ExecuterOption.None); // it's a good old fashion type now. try again.
                }
            }
            if (obj is IConvertible) {
                try {
                    result = Convert.ChangeType(obj, type);
                    return true;
                }
                catch(InvalidCastException) {
                    if (type.IsEnum) {
                        Number? n = obj as Number?;
                        if (n != null) {
                            return TryConvert((int)n, out result, ExecuterOption.Strict); // if we don't turn on strict, we'll have infinite recursion 8/22/16
                        }
                    }
                    return false;
                }
                catch (Exception ex) when (ex is FormatException || ex is OverflowException) {
                    return false;
                }
            }
            else {
                return false;
            }
        }

        internal static object ConvertFromString(string str)
        {
            // now we've just got to parse the supported types until we find a match...
            Number n;
            if (Number.TryParse(str, out n))
                return n;
            bool b;
            if (bool.TryParse(str, out b))
                return b;
            return null;
        }
    }
}
